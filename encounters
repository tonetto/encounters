#!/bin/bash

## This program is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License
## version 2 as published by the Free Software Foundation.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
##
## author: Leonardo Tonetto

trap 'kill_children_exit $WAITPID' EXIT

function kill_children_exit
{
    echo "Exiting..."
    while [ "$1" != "" ];
    do
        kill $1 2>/dev/null
        shift
    done
    exit
}

function usage
{
    echo "usage: encounter -o </output/path> -i <wlan0> [-m] [-c] | [-h]"
    echo ""
    echo "                 -o | --output:    /output/path for tcpdump"
    echo "                 -i | --interface: <wlan0> interface"
    echo "                 -m | --mapping:   mapping mode (check README)"
    echo "                 -h | --help:      shows this message"
    echo "                 -c | --chanhop:   Channel Hopper (check README)"
}


function channel_hopper
{
    c_seq="1 4 7 10 13 2 5 8 11 14 3 6 9 12"
    case `uname` in
        "Linux")
            # Figure out how to do this in Linux
            ;;
        "Darwin")
            # we'll use airport for this
            while true;
            do
                for channel in $c_seq;
                do
                    sudo airport --channel=$channel
                    sleep 5
                done
            done
            ;;
    esac
}

if [[ ! -x /usr/sbin/tcpdump ]];
then
    >&2 echo "Please install tcpdump and try again. Check README file for instructions."
    exit 1
fi

interface=
output_path=./
mapping=
channel_hopping=0
while [ "$1" != "" ];
do
    case $1 in
        -i | --interface)
            shift
            interface=$1
            ;;
        -o | --output )
            shift
            output_path=$1
            ;;
        -h | --help )
            usage
            exit
            ;;
        -m | --mapping )
            mapping=1
            ;;
        -c | --chanhop )
            channel_hopping=1
            ;;
        * )
            usage
            exit 1
            ;;
    esac
    shift
done

>&2 echo "To quit, press Q"
echo "Found the following Wireless interfaces:"
case `uname` in
    "Linux")
        for intrfc in `iw dev | grep Interface | awk '{print $2}'`; do echo $interfc; done
        ;;
    "Darwin")
        networksetup listallhardwareports | grep "Wi-Fi" -A1 | grep "Device" | awk '{print $2}'
        if [[ $channel_hopping -eq 1 ]];
        then
            >&2 echo "Disassociating WiFi"
            sudo airport -z            
        fi
        ;;
esac

if [[ -z $interface ]];
then
    >&2 echo "Please indicate the desired network interface"
    usage
    exit 1
fi

if [[ ! -d "$output_path" ]];
then
    >&2 echo "Please indicate a valid output path"
    usage
    exit 1
fi


## Timestamp function
timestamp=$(date +'%s')
## Some output for debug
echo "Calling TCPDUMP on interface $interface."

WAITPID=
tcpdump -i $interface -I -w $output_path/$timestamp.capture type mgt &
WAITPID="$WAITPID $!"
channel_hopper_pid=
if [[ $channel_hopping -eq 1 ]];
then
    echo "Channel Hopping"
    channel_hopper &
    WAITPID="$WAITPID $!"
fi

if [[ mapping -eq 1 ]];
then
    echo "Mode: Mapping"
else
    while true; do
        read -n 1 -s key
        if [[ $key = q ]];
        then
            kill_children_exit $WAITPID
        fi
    done
    wait
fi


state='STOPPED'
>&2 echo "Initial state: $state"
while true; do
    read -n 1 -s key
    
    if [[ $key = q ]];
    then
        kill_children_exit $WAITPID
    else
        if [[ "$state" = 'STOPPED' ]]; then
            state='MOVING'
        else
            state='STOPPED'
        fi
        echo "New state: $state !"
        current_ts=$(date +"%Y%m%d%H%M%S")
        echo $current_ts $state >>$output_path/$timestamp.mapping
    fi
done

